<html lang="en">
<head>
	<meta charset=utf-8 />
	<meta name="viewport" content="width=620" />
	<title>FACE FILTER</title>
	<meta property="title" content="Geometric Photo Filter"/>
	<meta property="og:title" content="Geometric Photo Filter"/>
	<meta property="og:type" content="website"/>
	<meta property="og:image" content="http://face.haluska.sk/face1.png"/>
	<meta property="og:image" content="http://face.haluska.sk/face2.png"/>
	<meta property="og:image" content="http://face.haluska.sk/face3.png"/>
	<meta property="og:image" content="http://face.haluska.sk/face4.png"/>
	<meta property="og:image" content="http://face.haluska.sk/face5.png"/>
	<meta property="og:description" content="Photo filter based on random lookup for neighbouring pixels with similar color and shading via drawing basic geometric primitives."/>
	<meta property="og:url" content="http://face.haluska.sk" />
	<link rel="image_src" href="http://face1.png" / >
</head>
<body background="bg.gif">
<header style="min-width:100%;">
<table>
<tr><td class=title width=100% style="white-space: nowrap;">GEOMETRIC <fx style="color:#804000">//</fx> PHOTO FILTER <fx style="color:#F08000">/  /    /</fx></td><td align=right style="white-space: nowrap;">Â© 2014 <a target="_blank" href="http://Zd3N.com">Zden</a> | <a target="_blank" href="http://satori.sk">Satori SK</a> | <a target="_blank" href="http://github.org/zden/face.haluska.sk">source</a><br>ver. 1.15 | August/14/2014 | <a href="changelog.md" target="_blank">changelog</a></td></tr>
</table>
<script src="filesave/Blob.js"></script>
<script src="filesave/FileSaver.js"></script>
<script src="filesave/canvas-toBlob.js"></script>
</header>
<style>

input {
	color: #000000;
	font-family: "Verdana";
	font-size: 9pt;
	font-weight: normal;
	text-decoration: none;
}

td {
	color: #000000;
	font-family: "Verdana";
	font-size: 9pt;
	font-weight: normal;
	text-decoration: none;
	padding-left:8px;
}

p.drop {
	color: #ACD8F8;
	font-family: "Verdana";
	font-size: 20pt;
	font-weight: normal;
	text-decoration: none;
}

td.title {
	color: #808080;
	font-family: "Verdana";
	font-size: 20pt;
	font-weight: normal;
	text-decoration: none;
}

#holder { border: 2px dashed #ccc; border-color: #BBE0FA; width: 640px; height: 640px; margin: 20px auto; position: absolute; top: 48px; left: 440px; }
#holder.hover { border: 2px dashed #333; }
#holder.paint { border: 2px; }

#video_capture {
    width: 640px;
    height: 640px;
    background-color: transparent;
}

#video_div { border: 2px dashed #ccc; border-color: transparent; width: 640px; height: 640px; margin: 20px auto; position: absolute; top: 48px; left: 440px;
	visibility: hidden;
}

a {
	color: #206080;
	font-family: "Verdana";
	font-size: 9pt;
	font-weight: normal;
	text-decoration: none;
}

a:hover {
	color: #4080B0;
	background-color: #FFE0A0;
	font-family: "Verdana";
	font-weight: normal;
	text-decoration: none;
}

</style>
  <div id="UI" style="position: absolute; top: 40px; left: 0px;">
  <p>
	<table background="bgui.gif" width=220>
	<tr><td>
	<table width=420><tr><td width=210><input style="width: 130px;" id='save' type='button' value="&#9658; SAVE PAINTING" onclick=button_change(this) /></td><td>Name:</td><td><input id="filename" type="string" value="myface" size="8" onchange=value_change(this) /></td>
	<td width=210 align=right><input style="width: 80px;" id='play' type='button' value="&#9658; PAUSE" onclick=button_change(this) />&nbsp;&nbsp;&nbsp;</td></tr>
	</table>
		<table>
		<tr><td width=150>Presets:</td><td>
		<select style="width:150px;" id='preset' onChange=combo_change(this)>
			<option>- Select Preset -</option>
			<option>- - - - - - - - - - -</option>
			<option>> Basic Strong Lines</option>
			<option>> Rough Scatch</option>
			<option>> Hatched Shade</option>
			<option>> Recursive Lines</option>
			<option>> Blurred Water Color </option>
			<option>> Triangles</option>
			<option>> Horizontal Lines</option>
			<option>- - - - - - - - - - -</option>
			<option>Save Preset</option>
			<option>Load Preset</option>
		</select></td><td width=60></td>
		</tr>
		<tr><td colspan=4></td></tr>
		<tr><td bgcolor="#EED000" colspan=4></td></tr>
		<tr><td colspan=4></td></tr>
		<tr><td width=150>Shader:</td><td>
		<select style="width:105px;" id='shader' onChange=combo_change(this)>
			<option>Line</option>
			<option>Triangle</option>
			<option>Rectangle</option>
			<option>Circle</option>
			<option>Line Walker</option>
		</select></td><td></td>
		</tr>
	<tr><td>Filled Shader:</td><td><input id="shader_filled" type="checkbox" value="0" onchange=value_change(this) /></td><td></td><td></td><tr>
	<tr><td>Alfa:</td><td><input id="alfa" type="range" min="0" max="100" value="100" onchange=value_change(this) /></td><td><input style="width:64px;" id="alfa_num" type="number" min="0" max="100" value="100" onchange=value_change(this) /></td></tr>	
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EED000" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Line Width:</td><td><input id="line_width" type="range" min="1" max="100" value="1" onchange=value_change(this) /></td><td><input style="width:64px;" id="line_width_num" type="number" min="1" max="100" value="1" onchange=value_change(this) /></td></tr>	
	<tr><td>Line Cap:</td><td><select style="width:105px;" id='line_cap' onChange=combo_change(this)>
			<option>Butt</option>
			<option>Round</option>
			<option>Square</option>
		</select>
	</td></tr>	
	<tr><td>Gradient:</td><td><input id="gradient" type="checkbox" value="0" onchange=value_change(this) /></td><td></td><td></td><tr>
	<tr><td>Alfa End:</td><td><input id="alfa_end" type="range" min="0" max="100" value="100" onchange=value_change(this) /></td><td><input style="width:64px;" id="alfa_end_num" type="number" min="0" max="100" value="100" onchange=value_change(this) /></td></tr>
	<tr><td colspan=4><fx style="color:#808080; font-size: 8pt;">Alfa End works with Gradients only.</fx>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EED000" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Start Distance:</td><td><input id="pixel_start_dist" type="range" min="1" max="256" value="8" onchange=value_change(this) /></td><td><input style="width:64px;" id="pixel_start_dist_num" type="number" onchange=value_change(this) value="8" /></td></tr>
	<tr><td>Max Distance:</td><td><input id="pixel_dist" type="range" min="1" max="256" value="64" onchange=value_change(this) /></td><td><input style="width:64px;" id="pixel_dist_num" type="number" onchange=value_change(this) value="64" /></td></tr>
	<tr><td>Color Similiarity:</td><td><input id="pixel_similiar" type="range" min="1" max="128" value="1" onchange=value_change(this) /></td><td><input style="width:64px;" id="pixel_similiar_num" type="number" min="1" max="128" value="1" onchange=value_change(this) /></td></tr>
	<tr><td colspan=4><fx style="color:#808080; font-size: 8pt;">Value represents maximal difference between R/G/B components.<br>The lower the value, the more exact color you seek.</fx>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EED400" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Start Angle:</td><td><input id="angle_start" type="range" min="0" max="359" value="0" onchange=value_change(this) /></td><td><input style="width:64px;" id="angle_start_num" type="number" min="0" max="359" value="0" onchange=value_change(this) /></td></tr>
	<tr><td>Start Angle Randomize:</td><td><input id="angle_start_rand" type="range" min="0" max="359" value="359" onchange=value_change(this) /></td><td><input style="width:64px;" id="angle_start_rand_num" type="number" min="0" max="359" value="356" onchange=value_change(this) /></td></tr>
	<tr><td>Arc Length:</td><td><input id="arc_length" type="range" min="1" max="360" value="360" onchange=value_change(this) /></td><td><input style="width:64px;" id="arc_length_num" type="number" min="1" max="360" value="360" onchange=value_change(this) /></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EED800" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Fade by Distance:</td><td><input id="dist_fade" type="range" min="0" max="100" value="100" onchange=value_change(this) /></td><td><input style="width:64px;" id="dist_fade_num" type="number" min="0" max="100" value="100" onchange=value_change(this) /></td></tr>
	<tr><td>Inverted Fade:</td><td><input id="inverted_fade" type="checkbox" value="0" onchange=value_change(this) /></td><td></td><td></td><tr>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EEDB00" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Hue:</td><td><input id="hue" type="range" min="0" max="384" value="0" onchange=value_change(this) /></td><td><input style="width:64px;" id="hue_num" type="number" min="0" max="384" value="0" onchange=value_change(this) /></td></tr>
	<tr><td>Saturation:</td><td><input id="saturation" type="range" min="0" max="256" value="128" onchange=value_change(this) /></td><td><input style="width:64px;" id="saturation_num" type="number" min="0" max="256" value="128" onchange=value_change(this) /></td></tr>	
	<tr><td colspan=4><fx style="color:#808080; font-size: 8pt;">Values lower than 128 turns colors to gray tones.</fx>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#EEE000" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td>Steps per Frame: <fx style="color:#F02020; font-size: 8pt;"></fx></td><td><input id="steps" type="range" min="1" max="256" value="10" onchange=value_change(this) /></td><td><input style="width:64px;" id="steps_num" type="number" min="1" max="256" value="10" onchange=value_change(this) /></td></tr>
	<tr><td>Max Steps per Walk: <fx style="color:#F02020; font-size: 8pt;"></fx></td><td><input id="walk_steps" type="range" min="2" max="256" value="10" onchange=value_change(this) /></td><td><input style="width:64px;" id="walk_steps_num" type="number" min="2" max="256" value="10" onchange=value_change(this) /></td></tr>
	<tr><td colspan=4><fx style="color:#F07000; font-size: 8pt;"> Supporting WebWorkers. Higher values may slow down painting but will not brick your browser.</fx>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#D0D0D0" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	</table>
	<div id='gif_expand' style="display:block;">&nbsp;&nbsp;&nbsp;<a href="#" onclick="return txt_open('gif_expand', 'gif_options');">show gif options</a></div>
	<div id='gif_options' style="display:none;">
	<table>
		<tr><td><input style="width: 100px;" id='gif_frame' type='button' value="SNAP FRAME" onclick=button_change(this) /></td>
		<td><p id="gif_status"></p></td><td><input style="width: 60px;" id='gif_save' type='button' value="SAVE" onclick=button_change(this) /></td></tr>
		<tr><td width=150>Frames:</td><td><input type="text" id="gif_frames" readonly style="width: 30px;" /></td></tr>
		<tr><td>Automatic Snap:</td><td><input id="gif_auto" type="checkbox" value="0" onchange=value_change(this) /></td></tr>
		<tr><td>Snap Period:</td><td><input style="width:64px;" id="gif_auto_period" type="number" onchange=value_change(this) value="10" /></td></tr>
		<tr><td>Gif Frame Duration:</td><td><input style="width:64px;" id="gif_time" type="number" onchange=value_change(this) value="100" /></td></tr>
		<tr><td>Loop:</td><td><input id="gif_loop" type="checkbox" value="0" onchange=value_change(this) /></td></tr>
<!--	<tr><td>Transparent:</td><td><input id="gif_trans" type="checkbox" value="0" onchange=value_change(this) /></td></tr> -->
		<tr><td width=150>Resolution:</td><td width=160>
			<select style="width:105px;" id='gif_res' onChange=combo_change(this)>
				<option>Scaled</option>
				<option>Fixed Width</option>
				<option>Fixed Height</option>
				<option>Fixed Res</option>
			</select>
			</td><td><input style="width: 60px;" id='gif_set' type='button' value="RESET" onclick=button_change(this) /></td></tr>
		<tr><td>Scale:</td><td><input style="width:64px;" id="gif_scale" type="number" onchange=value_change(this) value="25" /></td></tr>
		<tr><td>Width:</td><td><input style="width:64px;" id="gif_wid" type="number" onchange=value_change(this) value="32" /></td></tr>
		<tr><td>Height:</td><td><input style="width:64px;" id="gif_hei" type="number" onchange=value_change(this) value="32" /></td></tr>
		<tr><td colspan=3><fx style="color:#808080; font-size: 8pt;">Press RESET to use your newly selected gif resolution (previous unsaved gif will be lost). Looping can be changed before the first snapped frame only. Duration can be adjusted for every frame separately.</fx></td></tr>
	</table>
	</div>
	<table width=420>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#D0D0D0" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	<tr><td><input style="width: 140px;" id='orig' type='button' value="SHOW ORIGINAL" onclick=button_change(this) /></td><td><input style="width: 85px;" id='restart' type='button' value="&#8857; RESTART" onclick=button_change(this) /></td><td></td></tr>
	<tr><td>Start with:</td><td>
	<select id='start' onChange=combo_change(this)>
		<option>White Canvas</option>
		<option>Black Canvas</option>
		<option style="background-color:orange" id="canvas_color_option">Custom Color</option>
	</td><td></td></tr>
	<tr><td width=150>Custom Color:</td><td width=190><input id="canvas_color" type="string" value="orange" size="9" onchange=value_change(this) /></td><td style="background-color:orange;" id="canvas_color_td" width=70></td><td width=10></td></tr>
	<tr><td colspan=4><fx style="color:#808080; font-size: 8pt;">Color by English name or RGB value in hexadecimal.</fx>
	<tr><td colspan=4></td></tr>
	<tr><td bgcolor="#D0D0D0" colspan=4></td></tr>
	<tr><td colspan=4></td></tr>
	</table>
	<tr><td>
	<table><tr><td style="text-align: justify;">
	<b>Usage:</b><br><desc style="color:#505070">Drag and drop some image and work with the values in real-time to make your generative version. You have basic geometric primitives to choose from and full real-time parametric control over the painting algorithm. Use Pause/Play to set parameters comfortably, have a look at original picture for comparison, and when you are satisfied with your creation, you can save it to a new browser tab. This filter performs best on high detailed portrait pictures. If you want to start on another picture just drop it onto the drawing area.</desc><p>
	<b>About:</b><br><desc style="color:#505070">
	Photo filter based on random lookup for neighbouring pixels with similar color property and applying found pixels' positions and color for shading via drawing basic geometric primitives.
	<br><br>Seek for the similar pixel is started from the center radially. You can set starting and ending seek distance as well range of the circle sector. Alpha is calculated according to the distance of found pixels. "Line Walk" is a special mode when line primitive repeats seek process multiple times for the same color starting again from the newly found pixel.</desc><p>
	<b>Future:</b><br><desc style="color:#505070">If you like the filter <a href="http://www.facebook.com/GeometricPhotoFilter">share your interest or creations</a>. I have a couple of ideas to progress this further. Some of them are about the new parameters to control colors or extend Walk feature to other primitives. I am especially interested to implement ability to record all your actions with feature to reapply these steps on another picture which gives a possibility for motion video application.</desc><p>
	</td></tr>
	<tr><td>
	</td></tr>
	</table></td></tr>
</table>
  </div>
  <div style="position: absolute;top:340px;left:690px;"><p class=drop>[&nbsp;drop&nbsp;image&nbsp;]</p></div>
  <div style="position: absolute;top:690;left:435;z-index:99;visibility:hidden" id="divcapture"><p class=drop>
	<label for="capture" class="captureButton">[ camera capture ]</label>
	<input style="opacity:0" accept="image/*" name="capture" id="capture" capture="camera" onclick="camera_start();"><br>
	</div>
	<div style="position: absolute;top:724;left:705;z-index:99;visibility:hidden" id="divcapture_con"><input type="button" value="&#9679;&nbsp;SNAP" id="snap">&nbsp;&nbsp;<input type="button" value="&#9632;&nbsp;STOP" id="stop"></div>
  <div style="position: absolute;top:690;left:862;z-index:99;" id="divupload"><p class=drop>
	<label for="upload" class="uploadButton">[ upload image ]</label>
	<input style="opacity:0" type="file" name="upload" id="upload">
	</div>
  <div id="holder"><canvas id='face' width=640 height=640 style='position:relative;'></canvas></div>
  <div id="video_div"><video autoplay="" id="video_capture">
  
  </video></div>

<script>

var val_canvas_color = new RGB(0xff, 0x80, 0x00);
var val_start_canvas = 0;
var val_shader = 0;
var val_shader_filled = 1;
var val_pixel_start_dist = 8, val_pixel_dist = 64;
var val_pixel_similiar = 2;
var val_angle_start = 0, val_angle_start_rand = 359, val_arc_length = 360;
var val_alfa = 100;
var val_alfa_end = 100;
var val_gradient = 0;
var val_line_width = 1;
var val_line_cap = 1;
var val_hue = 0;
var val_saturation = 128;
var val_dist_fade = 100;
var val_inverted_fade = 0;
var val_steps = 10;
var val_walk_steps = 10;
var val_play = 1, val_orig = 0;
var painting_snap = 0;
var painting_refresh = 0;
var painting_restart = 0;

var gif_frames = 0;
var gif_x_res, gif_y_res;
var val_gif_auto = 0;
var val_gif_auto_period = 50;
var val_gif_time = 25;
var val_gif_loop = 1;
var val_gif_trans = 1;
var val_gif_res = 0;
var val_gif_scale = 25;
var val_gif_wid = 32;
var val_gif_hei = 32;

var filename = "myface";

var GIF_SCALE = 0, GIF_WID = 1, GIF_HEI = 2, GIF_RES = 3;

var x_res = 640, y_res = 640;

function value_enable(id, en)
{
	(document.getElementById(id)).disabled = en ? "" : "disabled";
	(document.getElementById(id)).style.color = en ? "#000000" : "#E0E0E0";
}

function value_set(id, val)
{
	(document.getElementById(id)).value = val;
}

function check_set(id, val)
{
	(document.getElementById(id)).checked = val ? true : false;
}

function combo_set(id, val)
{
	(document.getElementById(id)).selectedIndex = val;
}

function button_refresh(id)
{
	switch (id) {
		case 'play':	value_set('play', val_play ?
								String.fromCharCode(9612)+String.fromCharCode(9612)+" PAUSE" :
								String.fromCharCode(9658)+" PLAY");
							break;

		case 'orig':	value_set('orig', val_orig ?
								String.fromCharCode(8710)+" SHOW PAINTING" :
								String.fromCharCode(9650)+" SHOW ORIGINAL");
							break;
	};
}

function painting_start()
{
	val_orig = 0; val_play = 1;
	button_refresh('play');
	painting_snap = painting_refresh = 0;
	img_painting_loaded = 0;
	button_refresh('play');
	button_refresh('orig');
	value_enable('play', 1);
	value_enable('orig', 1);
	value_enable('save', 1);
	value_enable('restart', 1);
	value_enable('gif_frame', 1);
	value_enable('gif_set', 1);
	gif_auto_cnt = 0;
}

var SHADER_LINE = 0;
var SHADER_TRIANGLE = 1;
var SHADER_BOX = 2;
var SHADER_CIRCLE = 3;
var SHADER_WALK = 4;

function change_shader(sh)
{
	val_shader = sh;
	refresh_enabled();
	combo_set("shader", sh);
}

update_controls();
value_set('canvas_color', 'orange');
value_enable('play', 0);
value_enable('orig', 0);
value_enable('save', 0);
value_enable('restart', 0);
button_refresh('play');
button_refresh('orig');
combo_set('preset',0);
combo_set('start',0);
value_enable('gif_frame', 0);
value_enable('gif_save', 0);
value_enable('gif_set', 0);

function value_get(id)
{
	return( (document.getElementById(id)).value );
}

function value_range(val, min, max)
{
	if (val < min) val = min;
	else
	if (val > max) val = max;

	return(val);
}

var img_original;
var img_painting;
var img_painting_loaded;

var preset_data = [
[ "val_shader" ],
[ "val_shader_filled" ],
[ "val_alfa" ],
[ "val_line_width" ],
[ "val_line_cap" ],
[ "val_gradient" ],
[ "val_alfa_end" ],
[ "val_hue" ],
[ "val_saturation" ],
[ "val_pixel_start_dist" ],
[ "val_pixel_dist" ],
[ "val_pixel_similiar" ],
[ "val_angle_start" ],
[ "val_angle_start_rand" ],
[ "val_arc_length" ],
[ "val_dist_fade" ],
[ "val_inverted_fade" ],
[ "val_steps" ],
[ "val_walk_steps" ],
];

function update_controls()
{
	value_set('pixel_dist', val_pixel_dist);
	value_set('pixel_dist_num', val_pixel_dist);
	value_set('pixel_start_dist', val_pixel_start_dist);
	value_set('pixel_start_dist_num', val_pixel_start_dist);
	value_set('pixel_similiar', val_pixel_similiar);
	value_set('pixel_similiar_num', val_pixel_similiar);
	value_set('angle_start', val_angle_start);
	value_set('angle_start_num', val_angle_start);
	value_set('angle_start_rand', val_angle_start_rand);
	value_set('angle_start_rand_num', val_angle_start_rand);
	value_set('arc_length', val_arc_length);
	value_set('arc_length_num', val_arc_length);
	value_set('alfa', val_alfa);
	value_set('alfa_num', val_alfa);
	value_set('alfa_end', val_alfa_end);
	value_set('alfa_end_num', val_alfa_end);
	value_set('line_width', val_line_width);
	value_set('line_width_num', val_line_width);
	check_set('gradient', val_gradient);
	value_set('hue', val_hue);
	value_set('hue_num', val_hue);
	value_set('saturation', val_saturation);
	value_set('saturation_num', val_saturation);
	combo_set('line_cap', val_line_cap);
	check_set('inverted_fade', val_inverted_fade);
	value_set('dist_fade', val_dist_fade);
	value_set('dist_fade_num', val_dist_fade);
	combo_set('shader', val_shader);
	value_set('steps', val_steps);
	value_set('steps_num', val_steps);
	value_set('walk_steps', val_walk_steps);
	value_set('walk_steps_num', val_walk_steps);
	change_shader(val_shader);
	check_set('shader_filled', val_shader_filled);
	
	value_set('gif_frames', gif_frames);
	check_set('gif_loop', val_gif_loop);
//	check_set('gif_trans', val_gif_trans);
	value_set('gif_time', val_gif_time);
	value_set('gif_scale', val_gif_scale);
	value_set('gif_wid', val_gif_wid);
	value_set('gif_hei', val_gif_hei);
	check_set('gif_auto', val_gif_auto);
	combo_set('gif_res', val_gif_res);
	value_set('gif_auto_period', val_gif_auto_period);

	refresh_enabled();
}

var preset_library = [
// basic lines
	[ "val_shader=0;val_shader_filled=1;val_alfa=71;val_line_width=4;val_line_cap=2;val_pixel_start_dist=4;val_pixel_dist=22;val_pixel_similiar=2;val_angle_start=0;val_angle_start_rand=359;val_arc_length=360;val_dist_fade=100;val_inverted_fade=0;val_steps=50;val_walk_steps=10;" ],
// rough scatch
	[ "val_shader=4;val_shader_filled=1;val_alfa=100;val_line_width=1;val_line_cap=1;val_pixel_start_dist=28;val_pixel_dist=76;val_pixel_similiar=2;val_angle_start=228;val_angle_start_rand=32;val_arc_length=150;val_dist_fade=100;val_inverted_fade=1;val_steps=10;val_walk_steps=138;" ],
// hatched shade
	[ " val_shader=0;val_shader_filled=1;val_alfa=29;val_line_width=1;val_line_cap=1;val_pixel_start_dist=8;val_pixel_dist=28;val_pixel_similiar=2;val_angle_start=45;val_angle_start_rand=12;val_arc_length=13;val_dist_fade=0;val_inverted_fade=0;val_steps=200;val_walk_steps=10;" ],
// recursive lines
	[ "val_shader=4;val_shader_filled=1;val_alfa=34;val_line_width=1;val_line_cap=1;val_pixel_start_dist=8;val_pixel_dist=14;val_pixel_similiar=3;val_angle_start=0;val_angle_start_rand=359;val_arc_length=360;val_dist_fade=46;val_inverted_fade=0;val_steps=3;val_walk_steps=50;" ],
// blurred water color
	[ "val_shader=3;val_shader_filled=1;val_alfa=10;val_line_width=1;val_line_cap=1;val_pixel_start_dist=5;val_pixel_dist=15;val_pixel_similiar=7;val_angle_start=0;val_angle_start_rand=359;val_arc_length=360;val_dist_fade=100;val_inverted_fade=0;val_steps=100;val_walk_steps=10;" ],
// triangles fillup
	[ "val_shader=1;val_shader_filled=1;val_alfa=100;val_line_width=1;val_line_cap=1;val_pixel_start_dist=44;val_pixel_dist=66;val_pixel_similiar=2;val_angle_start=0;val_angle_start_rand=359;val_arc_length=360;val_dist_fade=100;val_inverted_fade=0;val_steps=10;val_walk_steps=10;" ],
// horizontal lines
	[ "val_shader=0;val_shader_filled=1;val_alfa=100;val_line_width=3;val_line_cap=2;val_pixel_start_dist=6;val_pixel_dist=24;val_pixel_similiar=40;val_angle_start=90;val_angle_start_rand=0;val_arc_length=1;val_dist_fade=100;val_inverted_fade=0;val_steps=40;val_walk_steps=10;" ],
// hatched shade
];

function preset_save()
{
	var c = preset_data.length, a;
	var str = "";
	for (a = 0; a < c; a++)
		str += preset_data[a]+"="+eval(""+preset_data[a]+"")+";";
	alert("this is your preset data:\n\n"+str);
}

function preset_load(str)
{
	if (str == "")
	{
		str = prompt("enter your preset data: ", "");
		if (str == "") return;
	}
	var s_str = ""+str;
	var vals = s_str.split(';'), a, c = vals.length;
	if (!c) return;
	
	for (a = 0; a < c; a++)
	{
		eval(""+vals[a]+"");
	}
	update_controls();
}

function snap_painting(canvas)
{
	img_painting_loaded = 0;
	img_painting = new Image();
	img_painting.src = canvas.toDataURL("image/raw");
	img_painting.onload = function func() { img_painting_loaded = 1; };
}

function save_painting(canvas)
{
//	var img = canvas.toDataURL("image/png");
//	window.open(img);
	canvas.toBlob(function(blob) { saveAs(blob, filename + ".png"); }, "image/png");
}

function gif_add_frame()
{
	if (!gif_frames) gif_start();
	var ctx = canvas_gif.getContext('2d');
	ctx.drawImage(canvas, 0, 0, x_res, y_res, 0, 0, val_gif_wid, val_gif_hei);
	gif_data = ctx.getImageData(0,0, val_gif_wid, val_gif_hei).data;
	gif_worker.postMessage({cmd:'frame',frame:gif_data});
	gif_frames++;
	value_set('gif_frames', gif_frames);
	refresh_enabled();
}

function button_change(obj)
{
	switch (obj.id)
	{
		case 'save':
						if (!val_orig) save_painting(canvas);
						break;
		case 'play':
						val_play ^= 1;
						button_refresh(obj.id);
						break;

		case 'orig':
						if (val_orig && !img_painting_loaded) break;

						val_orig ^= 1;

						button_refresh('orig');
						if (val_orig)
						{
							val_play = 0;
							button_refresh('play');
							img_painting_loaded = 0;
							painting_snap = 1;
							value_enable('play', 0);
							value_enable('save', 0);
							value_enable('restart', 0);
						}
						else
						{
							value_enable('play', 1);
							value_enable('save', 1);
							value_enable('restart', 1);
							painting_refresh = 4;
						}
						break;

		case 'restart':
						painting_restart = 1;
						break;
		case 'gif_frame':
						gif_add_frame();
						break;
		case 'gif_save':
						gif_save();
						break;
		case 'gif_set':
						gif_set();
						break;
	}
}

function combo_change(obj)
{
	var val_preset, len;

	switch (obj.id)
	{
		case 'shader': change_shader( obj.selectedIndex ); break;
		case 'start' : val_start_canvas = obj.selectedIndex; break;
		case 'line_cap' : val_line_cap = obj.selectedIndex; break;
		case 'preset' :
			len = obj.length;
			val_preset = obj.selectedIndex;
			if (val_preset == len - 2) preset_save();
			else
			if (val_preset == len - 1) preset_load("");
			else
			if (val_preset >= 2 && val_preset < len - 3)
				preset_load(preset_library[val_preset - 2]);

			combo_set('preset', 0);
			break;
		case 'gif_res':
			val_gif_res = obj.selectedIndex;
			refresh_enabled();
			break;
	}
}

function refresh_enabled()
{
	value_enable("walk_steps", val_shader == SHADER_WALK);
	value_enable("walk_steps_num", val_shader == SHADER_WALK);
	value_enable("shader_filled", val_shader == SHADER_TRIANGLE || val_shader == SHADER_BOX || val_shader == SHADER_CIRCLE);
	value_enable("line_cap", val_shader == SHADER_LINE || val_shader == SHADER_WALK || (val_shader == SHADER_BOX && !val_shader_filled));
	value_enable('line_width', !val_shader_filled || (val_shader == SHADER_LINE || val_shader == SHADER_WALK));
	value_enable('line_width_num', !val_shader_filled || (val_shader == SHADER_LINE || val_shader == SHADER_WALK));
	value_enable('alfa_end', val_gradient);
	value_enable('alfa_end_num', val_gradient);
	value_enable("gif_scale", val_gif_res == GIF_SCALE);
	value_enable("gif_wid", val_gif_res == GIF_WID || val_gif_res == GIF_RES);
	value_enable("gif_hei", val_gif_res == GIF_HEI || val_gif_res == GIF_RES);
	value_enable("gif_loop", !gif_frames);
}

function value_change(obj)
{
	var val = Math.floor(obj.value);

	switch (obj.id)
	{
		case 'pixel_dist' :
		case 'pixel_dist_num' :
									val = value_range(val, 1, 256);
									value_set("pixel_dist_num", val);
									value_set("pixel_dist", val);
									val_pixel_dist = val;
									if (val < val_pixel_start_dist)
									{
										value_set("pixel_start_dist_num", val);
										value_set("pixel_start_dist", val);
										val_pixel_start_dist = val;										
									}
									break;

		case 'pixel_start_dist' :
		case 'pixel_start_dist_num' :
									val = value_range(val, 1, 256);
									if (val > val_pixel_dist) val = val_pixel_dist;
									value_set("pixel_start_dist_num", val);
									value_set("pixel_start_dist", val);
									val_pixel_start_dist = val;
									break;

		case 'pixel_similiar' :
		case 'pixel_similiar_num' :
									val = value_range(val, 1, 128);
									value_set("pixel_similiar_num", val);
									value_set("pixel_similiar", val);
									val_pixel_similiar = val;
									break;

		case 'angle_start':
		case 'angle_start_num':
									val = value_range(val, 0, 359);
									value_set("angle_start_num", val);
									value_set("angle_start", val);
									val_angle_start = val;
									break;

		case 'angle_start_rand':
		case 'angle_start_rand_num':
									val = value_range(val, 0, 359);
									value_set("angle_start_rand_num", val);
									value_set("angle_start_rand", val);
									val_angle_start_rand = val;
									break;

		case 'arc_length':
		case 'arc_length_num':
									val = value_range(val, 1, 360);
									value_set("arc_length_num", val);
									value_set("arc_length", val);
									val_arc_length = val;
									break;
									
		case 'inverted_fade':
									val_inverted_fade = Math.floor( obj.checked );
									break;

		case 'gradient':
									val_gradient = Math.floor ( obj.checked );
									refresh_enabled();
									break;

		case 'shader_filled':
									val_shader_filled = Math.floor( obj.checked );
									refresh_enabled();
									break;

		case 'alfa':
		case 'alfa_num':
									val = value_range(val, 0, 100);
									value_set("alfa_num", val);
									value_set("alfa", val);
									val_alfa = val;
									break;

		case 'alfa_end':
		case 'alfa_end_num':
									val = value_range(val, 0, 100);
									value_set("alfa_end_num", val);
									value_set("alfa_end", val);
									val_alfa_end = val;
									break;

		case 'line_width':
		case 'line_width_num':
									val = value_range(val, 1, 100);
									value_set("line_width_num", val);
									value_set("line_width", val);
									val_line_width = val;
									break;

		case 'hue':
		case 'hue_num':
									val = value_range(val, 0, 384);
									value_set("hue_num", val);
									value_set("hue", val);
									val_hue = val;
									break;

		case 'saturation':
		case 'saturation_num':
									val = value_range(val, 0, 256);
									value_set("saturation_num", val);
									value_set("saturation", val);
									val_saturation = val;
									break;

		case 'dist_fade':
		case 'dist_fade_num':
									val = value_range(val, 0, 100);
									value_set('dist_fade', val);
									value_set('dist_fade_num', val);
									val_dist_fade = val;
									break;

		case 'steps':
		case 'steps_num':
									val = value_range(val, 1, 256);
									value_set('steps', val);
									value_set('steps_num', val);
									val_steps = val;
									break;

		case 'walk_steps':
		case 'walk_steps_num':
									val = value_range(val, 2, 256);
									value_set('walk_steps', val);
									value_set('walk_steps_num', val);
									val_walk_steps = val;
									break;

		case 'filename':
									filename = obj.value;
		case 'canvas_color':
									(document.getElementById('canvas_color_td')).style.backgroundColor = obj.value;
									val_canvas_color.str = (document.getElementById('canvas_color_td')).style.backgroundColor;
									(document.getElementById('canvas_color_option')).style.backgroundColor = val_canvas_color.str;
									break;

		case 'gif_time':
									val = value_range(val, 1, 7777);
									value_set('gif_time', val);
									val_gif_time = val;
									gif_params();
									break;
		case 'gif_scale':
									val = value_range(val, 1, 200);
									value_set('gif_scale', val);
									val_gif_scale = val;
									break;
		case 'gif_wid':
									val = value_range(val, 1, x_res<<1);
									value_set('gif_wid', val);
									val_gif_wid = val;
									break;
		case 'gif_hei':
									val = value_range(val, 1, y_res<<1);
									value_set('gif_hei', val);
									val_gif_hei = val;
									break;

		case 'gif_loop':
									val_gif_loop = Math.floor( obj.checked );
									gif_params();
									break;
		case 'gif_trans':
									val_gif_trans = Math.floor( obj.checked );
									break;
		case 'gif_auto':
									val_gif_auto = Math.floor( obj.checked );
									refresh_enabled();
									break;
		case 'gif_auto_period':
									val = value_range(val, 1, 256);
									value_set('gif_auto_period', val);
									val_gif_auto_period = val;
									break;
	}

}

var holder = document.getElementById('holder');

if (typeof window.FileReader === 'undefined')
	alert("File API & FileReader is not available.\nYou can't drag and drop images to process filter.");

function line(con_, xs, ys, xe, ye, col, col_end, alfa, alfa_end, stroke, cap, grad)
{
	con_.lineWidth = stroke;
	var ae;

	if (!grad)
		con_.strokeStyle = col.str;
	else
	{
		gradient = con_.createLinearGradient(xs, ys, xe, ye);
		gradient.addColorStop(0, col.str);
		ae = (alfa*alfa_end)/100;
		gradient.addColorStop(1, 'rgba('+col_end.r+', '+col_end.g+', '+col_end.b+', '+ae+')');
		con_.strokeStyle = gradient;
	}
	con_.globalAlpha = alfa;
	con_.lineCap= !cap ? "butt" : cap == 1 ? "round" : "square";
	con_.beginPath();
	con_.moveTo(xs, ys);
	con_.lineTo(xe, ye);
	con_.stroke();
}

function circle(con_, x, y, r, filled, col, col_end, alfa, alfa_end, stroke, grad)
{
	con_.lineWidth = stroke;
	con_.globalAlpha = alfa;
	con_.beginPath();
	con_.arc(x, y, r, 0, 2 * Math.PI, false);
	var ae;
	
	if (grad)
	{
		if (filled)
			gradient = con_.createRadialGradient(x, y, 0, x, y, r);
		else
			gradient = con_.createRadialGradient(x, y, r-stroke/2 < 0 ? 0 : r - stroke/2, x, y, r+stroke/2);
		gradient.addColorStop(0, col.str);
		ae = (alfa*alfa_end)/100;
		gradient.addColorStop(1, 'rgba('+col_end.r+', '+col_end.g+', '+col_end.b+', '+ae+')');
		con_.fillStyle = gradient;
	}

	if (filled)
	{
		con_.fillStyle = !grad ? col.str : gradient;
		con_.fill();
	}
	else
	{
		con_.globalAlpha = alfa;
		con_.strokeStyle = !grad ? col.str : gradient;
		con_.stroke();
	}
}

function triangle(con_, x1, y1, x2, y2, x3, y3, filled, col, col_mid, col_end, alfa, alfa_end, stroke, grad)
{
	con_.lineWidth = stroke;
	con_.beginPath();
	con_.moveTo(x1, y1);
	con_.lineTo(x2, y2);
	con_.lineTo(x3, y3);
	con_.lineTo(x1, y1);
	con_.globalAlpha = alfa;
	con_.closePath();
	var ae;
	
	if (grad)
	{
		if (filled)
		{
			gradient = con_.createLinearGradient(x1, y1, x2, y2);
			gradient.addColorStop(0, col.str);
			ae = (alfa*alfa_end)/100;
			gradient.addColorStop(1, 'rgba('+col_mid.r+', '+col_mid.g+', '+col_mid.b+', '+ae+')');
			con_.fillStyle = gradient;
			con_.globalAlpha = alfa;
			con_.fill();
			gradient = con_.createLinearGradient(x1, y1, x3, y3);
			gradient.addColorStop(0, 'rgba('+col.r+', '+col.g+', '+col.b+', 0)');
			gradient.addColorStop(1, 'rgba('+col_end.r+', '+col_end.g+', '+col_end.b+', '+ae+')');
			con_.fillStyle = gradient;
			con_.globalAlpha = alfa/2;
			con_.fill();
		}
		else
		{
			line(con_, x1, y1, x2, y2, col, col_mid, alfa, alfa_end, stroke, 1, grad);
			line(con_, x2, y2, x3, y3, col_mid, col_end, alfa, alfa_end, stroke, 1, grad);
			line(con_, x3, y3, x1, y1, col_end, col, alfa, alfa_end, stroke, 1, grad);
		}
	}
	else
	if (filled)
	{
		con_.fillStyle = grad ? gradient : col.str;
		con_.fill();
	}
	else
	{
		context.strokeStyle = grad ? gradient : col.str;
		context.stroke();
	}
}

function rect(con_, x1, y1, wid, hei, filled, col, col_end, alfa, alfa_end, stroke, grad)
{
	if (grad && !filled)
	{
		line(con_, x1, y1, x1+wid, y1, col, col_end, alfa, alfa_end, stroke, val_line_cap, 1);
		line(con_, x1+wid, y1, x1+wid, y1+hei, col_end, col, alfa, alfa_end, stroke, val_line_cap, 1);
		line(con_, x1+wid, y1+hei, x1, y1+hei, col, col_end, alfa, alfa_end, stroke, val_line_cap, 1);
		line(con_, x1, y1+hei, x1, y1, col_end, col, alfa, alfa_end, stroke, val_line_cap, 1);
		
		return;
	}

	con_.lineWidth = stroke;
	con_.beginPath();
	con_.globalAlpha = alfa;

	con_.rect(x1, y1, wid, hei);
	
	var ae;

	if (filled)
	{
		if (!grad)
			con_.fillStyle = col.str;
		else
		{
			gradient = con_.createLinearGradient(x1, y1, x1+wid, y1+hei);
			gradient.addColorStop(0, col.str);
			ae = (alfa*alfa_end)/100;
			gradient.addColorStop(1, 'rgba('+col_end.r+', '+col_end.g+', '+col_end.b+', '+ae+')');
			con_.fillStyle = gradient;
		}
		con_.fill(); 
	}
	else
	{
		con_.strokeStyle = col.str;
		con_.stroke();
	}
}

function rgbColor(r,g,b)
{
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function RGB(r,g,b)
{
	this.r = r;
	this.g = g;
	this.b = b;
	this.str = 'rgb(' + r + ',' + g + ',' + b + ')';
	return this;
}

function hue_satur(col)
{
	var r, g, b;
	var l = val_hue;
	var s = val_saturation;

	if (l == 0)
	{
		r = col.r;
		g = col.g;
		b = col.b;
	}
	else
	if (l > 0 && l <= 127)
	{
		r = (col.r*(127-l))/128 + (col.g*l)/128;
		g = (col.g*(127-l))/128 + (col.b*l)/128;
		b = (col.b*(127-l))/128 + (col.r*l)/128;
	}
	else
	if (l >= 128 && l <= 255)
	{
		l -= 128;
		r = (col.g*(127-l))/128 + (col.b*l)/128;
		g = (col.b*(127-l))/128 + (col.r*l)/128;
		b = (col.r*(127-l))/128 + (col.g*l)/128;
	}
	else
	if (l >= 256 && l <= 384)
	{
		l -= 256;
		r = (col.b*(127-l))/128 + (col.r*l)/128;
		g = (col.r*(127-l))/128 + (col.g*l)/128;
		b = (col.g*(127-l))/128 + (col.b*l)/128;
	}

	if (isNaN(r)) r = 0;
	if (isNaN(g)) g = 0;
	if (isNaN(b)) b = 0;

	if (s != 128)
	{
		if (s < 128)
		{
			var gr = ((0.299*r + 0.587*g + 0.114*b)*(128 - s))/128 ;
			r = gr + (r * s)/128;
			g = gr + (g * s)/128;
			b = gr + (b * s)/128;
		}
		else
		{
			s -= 128;
			var str;

			if (r > g && r > b)
				str = 255 / r;
			else
			if (g > r && g > b)
				str = 255 / g;
			else
				str = 255 / b;

			r = ( ((r * str) * s) + (r * (128 - s)) )/128;
			g = ( ((g * str) * s) + (g * (128 - s)) )/128;
			b = ( ((b * str) * s) + (b * (128 - s)) )/128;
			if (isNaN(r)) r = 0;
			if (isNaN(g)) g = 0;
			if (isNaN(b)) b = 0;
		}
	}

	col.r = Math.floor(r); col.g = Math.floor(g); col.b = Math.floor(b);
	col.str = 'rgb(' + col.r + ',' + col.g + ',' + col.b + ')';
	return(col);
}

function rnd(n)
{
  return Math.floor( Math.random() * n );
}

window.requestAnimFrame = (function(callback) {
	return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
	function(callback) {
	window.setTimeout(callback, 1000 / 60);
	};
})();

// ---------- image, image_data, basic cols ----------

var gif_encoder;
var img_data;
var col_white = new RGB ( 255, 255, 255 );
var col_black = new RGB ( 0, 0, 0 );

var DVAPI = 2*Math.PI;

function get_alfa(dist)
{
	var alfa = (0.01 + dist - val_pixel_start_dist ) / ( val_pixel_dist - val_pixel_start_dist );
	if (!val_inverted_fade) alfa = 1 - alfa;
	alfa = (val_alfa * alfa) / 100;
	alfa = ( val_alfa * (100 - val_dist_fade) ) / (100*100) + ( alfa * val_dist_fade ) / 100;

	return (alfa);
}

// ---------- gif worker ----------

var gif_worker = new Worker('gifworker.js');
var gif_frames_proc = 0;

gif_worker.addEventListener('message', function(e) {
	switch(e.data.cmd)
	{
		case 'start':
					gif_frames_proc = 0;
					break;
		case 'frame':
					gif_frames_proc++;

					if (gif_frames == gif_frames_proc)
					{
						gif_set_status("");
						value_enable('gif_save', 1);
					}
					else
					{
						gif_set_status("encoded frame "+gif_frames_proc);
						value_enable('gif_save', 0);
					}
					break;
		case 'gif':
					gif_set_status("saving gif");
					saveAs(base64toBlob(e.data.gif, "image/gif"), filename+".gif");
					gif_set();
					value_enable('gif_save', 1);
					value_enable('gif_frame', 1);
					refresh_enabled();
					break;
	}
}, false);

// ---------- filter worker ----------

var worker = new Worker('filter.js');
worker.postMessage({cmd:'start'});

// ---------- worker "callback" used to paint all calculated shapes ----------

worker.addEventListener('message', function(e) {
	var a, c, d, p;

	d = e.data.out;
	c = d.length;
	switch (e.data.shader)
	{
		case SHADER_LINE:
		case SHADER_WALK:
			for (a = 0; a < c; a++)
			{
				p = d[a];
				line(context, p.x, p.y, p.xx, p.yy, hue_satur(p.col), hue_satur(p.col_end), p.alfa, val_alfa_end, val_line_width, val_line_cap, val_gradient);
			}
			break;
		case SHADER_TRIANGLE:
			for (a = 0; a < c; a++)
			{
				p = d[a];
				triangle(context, p.x, p.y, p.xx, p.yy, p.xxx, p.yyy, val_shader_filled, hue_satur(p.col), hue_satur(p.col_end), hue_satur(p.col_mid), p.alfa, val_alfa_end, val_line_width, val_gradient);
			}
			break;
		case SHADER_CIRCLE:
			for (a = 0; a < c; a++)
			{
				p = d[a];
				circle(context, p.x, p.y, p.r, val_shader_filled, hue_satur(p.col), hue_satur(p.col_end), p.alfa, val_alfa_end, val_line_width, val_gradient);
			}
			break;
		case SHADER_BOX:
			for (a = 0; a < c; a++)
			{
				p = d[a];
				rect(context, p.x, p.y, p.xx, p.yy, val_shader_filled, hue_satur(p.col), hue_satur(p.col_end), p.alfa, val_alfa_end, val_line_width, val_gradient);
			}
			break;
	}
	worker_called = 0;
}, false);

var worker_called = 0;

// ---------- frame refresh ----------

var favicon_refresh_count = 0;

var gif_auto_cnt = 0;

function animate_paint(canvas, context)
{
	var a, c, x, y, p;
	var col, col_end, col_mid;
	var xx, yy, xxx, yyy, ang, pp, dist;
	var ang_s, ang_e, found;
	var alfa;

	if (painting_refresh)
	{
		//rect(context, 0, 0, x_res, y_res, 1, col_white, 1);
		painting_refresh = 0;
		context.globalAlpha = 1;
		context.drawImage(img_painting, 0, 0, x_res, y_res);
	}

	if (painting_restart && !worker_called)
	{
		painting_restart = 0;
		rect(context, 0, 0, x_res, y_res, 1, val_start_canvas == 2 ? val_canvas_color : !val_start_canvas ? col_white : col_black, col_black, 1, 1, 0);
	}

	got_data = 0;

	if (val_play && !worker_called)
	{
		worker.postMessage({cmd:'do',val_steps:val_steps,val_walk_steps:val_walk_steps,val_shader:val_shader,val_alfa:val_alfa,
														val_pixel_start_dist:val_pixel_start_dist,val_pixel_dist:val_pixel_dist,
														val_angle_start:val_angle_start, val_angle_start_rand:val_angle_start_rand, val_arc_length:val_arc_length,
														val_pixel_similiar:val_pixel_similiar,val_inverted_fade:val_inverted_fade,val_dist_fade:val_dist_fade});
		worker_called = 1;
	}

	if (painting_snap)
	{
		painting_snap = 0;
		snap_painting(canvas);
	}
	if (val_orig)
	{
		context.globalAlpha = 1;
		context.drawImage(img_original, 0, 0, x_res, y_res);
	}

	if (!favicon_refresh_count)
	{
		favicon_context.globalAlpha = 1;
		favicon_context.drawImage(canvas, 0, 0, 16, 16);
		favicon_link.href = favicon_canvas.toDataURL("image/x-icon");
		document.getElementsByTagName('head')[0].appendChild(favicon_link);
	}
	favicon_refresh_count++;
	favicon_refresh_count %= 32;

	if (val_gif_auto && !gif_auto_cnt && val_play)
	{
		gif_add_frame();
	}
	gif_auto_cnt++;
	gif_auto_cnt %= val_gif_auto_period;

	requestAnimFrame(function() { animate_paint(canvas, context); });
}

// ^^^ update loop

// ---------- canvas init/resize, grab image data, start filtering ----------

var canvas = 0, context = 0;
var canvas_gif = 0;
function paint(face_img, video)
{
	if (!canvas) { canvas = document.getElementById('face'); canvas_gif = document.getElementById('gif'); }
	if (!context) context = canvas.getContext('2d');

	var wid, hei;
	
	if (!video)
	{
		wid = face_img.width;
		hei = face_img.height;
	}
	else
	{
		wid = face_img.videoWidth;
		hei = face_img.videoHeight;
	}

	if (wid > hei)
	{
		x_res = wid/hei*640;
		y_res = 640;
	}
	else
	{
		x_res = 640;
		y_res = hei/wid*640;
	}
	x_res &= 0xfff0;
	y_res &= 0xfff0; // js is very slow on unaligned data width
	
	divupload = document.getElementById('divupload');
	divupload.style.left = (860+(x_res-640))+"px";
	divupload.style.top = (690+(y_res-640))+"px";

	divcapture = document.getElementById('divcapture');
	divcapture.style.top = (690+(y_res-640))+"px";

	divupload = document.getElementById('divcapture_con');
	divupload.style.left = (705+((x_res-640)>>1))+"px";
	
	
	holder.className = 'paint';
	holder.style.width = x_res+"px";
	holder.style.height = y_res+"px";
	canvas.width = x_res;
	canvas.height = y_res;
	canvas.style.width = x_res+"px";
	canvas.style.height = y_res+"px";

	video = document.getElementById('video_capture');
	video.style.width = x_res+"px";
	video.style.height = y_res+"px";
	video.width = x_res;
	video.height = y_res;

// io6 squash issue fix -> http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
	context.drawImage(face_img, 0, 0, x_res, y_res);

	gif_set();

	var imageData = context.getImageData(0, 0, x_res, y_res);
	img_data = imageData.data;
	worker.postMessage({cmd:'img',img_data:img_data,x_res:x_res,y_res:y_res});

	if (!video)
		img_original = face_img;
	else
	{
		img_original = new Image();
		img_original.src = canvas.toDataURL("image/raw");
		video_div.style.visibility = "hidden";
	}

	rect(context, 0, 0, x_res, y_res, 1, val_start_canvas == 2 ? val_canvas_color : !val_start_canvas ? col_white : col_black, col_black, 1, 1, 0);

	painting_start();

	animate_paint(canvas, context);
}

// ---------- drop/upload of image ----------

function read_image(file)
{
	reader = new FileReader();
	reader.onload = function (event) {
		var img = new Image();
		img.src = event.target.result;
		img.onload = function () { paint(img, 0); };
	}
	reader.readAsDataURL(file);
}

holder.ondragover = function () { this.className = 'hover'; return false; };
holder.ondragleave = function () { this.className = ''; return false; };
holder.ondrop = function (e) {

  this.className = '';
  e.stopPropagation();
  e.preventDefault();
  
  read_image(e.dataTransfer.files[0]);

  return false;
};

function file_select(evt)
{
	read_image(evt.target.files[0]);
}
document.getElementById('upload').addEventListener('change', file_select, false);
document.getElementById('capture').addEventListener('change', file_select, false);

// ---------- fav icon init ----------

var favicon_canvas = document.createElement('canvas');
favicon_canvas.width = 16;
favicon_canvas.height = 16;
var favicon_context = favicon_canvas.getContext('2d');
var fav_col1 = new RGB(0x80, 0x40, 00);
var fav_col2 = new RGB(0xF0, 0x90, 00);
line(favicon_context, 0, 15, 4, 1, fav_col1, fav_col1, 1, 1, 1, 0, 0);
line(favicon_context, 3, 15, 4+3, 1, fav_col1, fav_col1, 1, 1, 1, 0, 0);
line(favicon_context, 6, 15, 4+6, 1, fav_col2, fav_col2, 1, 1, 1, 0, 0);
line(favicon_context, 9, 15, 4+9, 1, fav_col2, fav_col2, 1, 1, 1, 0, 0);
line(favicon_context, 12, 15, 4+12, 1, fav_col2, fav_col2, 1, 1, 1, 0, 0);
var favicon_link = document.createElement('link');
favicon_link.type = 'image/x-icon';
favicon_link.rel = 'shortcut icon';
favicon_link.href = favicon_canvas.toDataURL("image/x-icon");
document.getElementsByTagName('head')[0].appendChild(favicon_link);

// Wilder's quote: I like art because I consider it to be the highest form of unregulated freedom.

// ---------- camera capture ----------

var video = document.getElementById("video_capture");
var video_div = document.getElementById("video_div");
var controls_div = document.getElementById('divcapture_con');
var video_stream;

function is_camera()
{
	return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
}

if (is_camera()) // show capture button
{
	divcapture = document.getElementById('divcapture');
	divcapture.style.visibility = "visible";
}

function camera_start()
{
	if (canvas)
	{
		val_play = 0;
		button_refresh('play');
		value_enable('play', 0);
	}

	video_div.style.visibility = "visible";
	controls_div.style.visibility = "visible";

	video = document.getElementById("video_capture");
	videoObj = { "video": true },
		errBack = function(error) {
		console.log("Video capture error: ", error.code); 
	};

	if(navigator.getUserMedia)
	{
		navigator.getUserMedia(videoObj, function(stream) {
			video_stream = stream;
			video.src = stream;
			video.play();
		}, errBack);
	}
	else
	if(navigator.webkitGetUserMedia)
	{
		navigator.webkitGetUserMedia(videoObj, function(stream){
			video_stream = stream;
			video.src = window.webkitURL.createObjectURL(stream);
			video.play();
		}, errBack);
	}
	else
	if(navigator.mozGetUserMedia)
	{
		navigator.mozGetUserMedia(videoObj, function(stream){
			video_stream = stream;
			video.src = window.URL.createObjectURL(stream);
			video.play();
		}, errBack);
	}
	else
		alert("Camera Capture Not Supported!");
}

var video_feed = 0;

document.addEventListener('DOMContentLoaded', function()
{
	video_feed = document.getElementById('video_capture');
});

document.getElementById('snap').addEventListener('click', capture_snap);
document.getElementById('stop').addEventListener('click', capture_stop);

function capture_stop(e)
{
	if (video_stream != undefined)
	{
		video_feed.pause();
		video_stream.stop();
		video_stream.onended = null;
		video_stream = null;	
		video_feed.src = 0;
		video_feed.mozSrcObject = null;
	}
	video_div.style.visibility = "hidden";
	controls_div.style.visibility = "hidden";
	if (canvas) value_enable('play', 1);
}

function capture_snap(e)
{
	if (video_feed.videoWidth == 0) return capture_stop(e);
	paint(video_feed, 1);
	capture_stop(e);
};

function txt_open(id, cont)
{
	var ldiv =  document.getElementById(id);
	ldiv.style.display = "none";
	ldiv =  document.getElementById(cont);
	ldiv.style.display = "block";
	return false;
}

function txt_close(id, cont)
{
	var ldiv =  document.getElementById(id);
	ldiv.style.display = "block";
	ldiv =  document.getElementById(cont);
	ldiv.style.display = "none";
	return false;
}

// as found on http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript
function base64toBlob(base64Data, contentType) {
    contentType = contentType || '';
    var sliceSize = 1024*1024;
    var byteCharacters = atob(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);

    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);

        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
}
// ^

function gif_save()
{
	gif_set_status("exporting gif");
	gif_worker.postMessage({cmd:'save'});
	gif_frames = 0;
	value_set('gif_frames', gif_frames);
	value_enable('gif_save', 0);
	value_enable('gif_frame', 0);
	check_set('gif_auto', 0);
	val_gif_auto = 0;
}

function gif_set()
{
	switch (val_gif_res)
	{
		case GIF_SCALE:
			gif_x_res = Math.floor((x_res * val_gif_scale)/100);
			gif_y_res = Math.floor((y_res * val_gif_scale)/100);
			val_gif_wid = gif_x_res;
			val_gif_hei = gif_y_res;
			break;
		case GIF_WID:
			val_gif_hei = Math.floor((x_res * val_gif_wid) / y_res);
			break;
		case GIF_HEI:
			val_gif_wid = Math.floor((y_res * val_gif_hei) / x_res);
			break;
		case GIF_RES:
			break;
	}
	value_set("gif_wid", val_gif_wid);
	value_set("gif_hei", val_gif_hei);
	canvas_gif.width = val_gif_wid;
	canvas_gif.height = val_gif_hei;
	canvas_gif.style.width = val_gif_wid+"px";
	canvas_gif.style.height = val_gif_hei+"px";

	gif_frames = 0;
	value_set('gif_frames', gif_frames);
	gif_set_status("");
}

function gif_set_status(str)
{
	if (str == "") str = "gif resolution: "+val_gif_wid+"*"+val_gif_hei;
	status = document.getElementById('gif_status').innerHTML = str;
}

function gif_params()
{
	gif_worker.postMessage({cmd:'params',time:val_gif_time});
}

function gif_start()
{
	gif_worker.postMessage({cmd:'start',loop:val_gif_loop,time:val_gif_time,wid:val_gif_wid,hei:val_gif_hei/*,trans:val_gif_trans,trans_color:tc*/});
	gif_frames = 0;
	value_set('gif_frames', gif_frames);
}

</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40773143-2', 'haluska.sk');
  ga('send', 'pageview');

</script>

<div id="gif_scaled"><canvas id='gif' width=128 height=128 style='position:relative;visibility:hidden'></canvas></div>

</body>
</html>
